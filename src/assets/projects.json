[
    {
        "title": "Log Change Email Notifier",
        "summary": "A Spring application that examines a text file and if lines were added to the end of the file then it sends the new lines via email. Designed to work with LOG files that append lines in a file and never modify previous entries.",
        "motivation": "I have several personal projects that use log files. Many of these projects are running on headless Raspberry Pi micro computers, thus taking a look at these logs would mean connecting to them via SSH, getting to the log files, inspecting them, trying to remember what are the new lines… To fix this issue I decided to create a Java / Spring application that reads a log file, compares the number of lines in the file to the previously read number of lines, and if there are new ones, it sends an email notification to any given email address. This app can then be scheduled to run periodically to always have updates on a specific log file.",
        "functionality": "This is a wireframe that can be further modified for any specific usage. What this application does is it runs and checks if a specific text file has new lines appended at the end, and if it has then it sends an email notification with the new lines as the email’s body. It is important that this application is meant to work with log files, meaning that new lines are linearly appended to the file’s end, and nothing is ever modified. When the script is launched from a terminal, the target email address and log file can be given as parameters for easy configuration. The FROM email address can be configured in the application.properties file and is currently set for gmail addresses.",
        "challenges": [
            "I had to make sure the application is easily configured and is as lightweight as possible (to be run from a terminal with configurable options).",
            "I had to make sure the file reading and manipulation works exactly as expected."
        ],
        "futureImprovements": [
            "I was thinking about making it possible to use the application with multiple log files, but for now I just settled on using different instances of the app running for each log file.",
            "I was thinking about making it possible to use the application with multiple log files, but for now I just settled on using different instances of the app running for each log file."
        ],
        "techStack": ["Java", "Spring", "Maven", "Spring Boot Starter Mail dependency for sending the mails"],
        "folder": "log_change_email_notifier",
        "links": [
            {"name": "GitHub2", "link": "https://github.com/raczmirko/log-change-email-notifier"}
        ]
    },
    {
        "title": "Birdcam",
        "summary": "The BirdCam project was my first academic IoT project featuring a Raspberry Pi micro computer and an IP camera to take images of birds at my bird feeder. The project was a success and was later published in the journal of the Association of Hungarian IT Teachers",
        "motivation": "I have always loved animals and nature, so I had this idea of creating a motion-triggered camera system that would take pictures of the birds we feed automatically. I also wanted to crete something useful to practice some of the principles I learned during my first semester at university, such as networking or linux basics. ",
        "functionality": "The brain of the operation is a Raspberry Pi micro computer, running MotionEye for handling the motion detection. The images are taken with an IP camera connected to the Pi via the local network.",
        "challenges": [
            "Configuring the Raspberry Pi to run headless, so that I could easily SSH into the machine and control it from anywhere within the local network.",
            "Setting the motion trigger up precisely so that it doesn't trigger too often nor too few times.",
            "Building an optimal hardware setup. I have made several prototypes to finally find the one that fit me."
        ],
        "futureImprovements": [
            "Bird recognition using AI.",
            "Storing the images in the cloud for easier access"
        ],
        "techStack": ["Linux", "MotionEye"],
        "folder": "birdcam",
        "links": [
            {"name": "Publication link", "link": "https://isze.hu/wp-content/uploads/2021/09/Inspiracio2021_3.pdf"}
        ]
    },
    {
        "title": "Birdcam digital frame",
        "summary": "A digital picture frame to showcase the images my Birdcam project captured.",
        "motivation": "The Birdcam project was a success, and I wanted to show the resulting images to friends and family, but it was not convenient having to join the Birdcam, browse the photos, show it on a small mobile screen and so on, so I decided to make a custom digital frame for this purpose.",
        "functionality": "The frame is using a Rapsberry Pi Zero micro computer, which runs a custom Python slideshow app that I made to display images from a predefined folder. The Birdcam was connected to this folder over the local network via FTP, thus the frame would always have new photos the Birdcam made. I made a second version of the frame which had buttons to allow manual interaction with the slideshow, as well as a new hardware design with a glass window to expose the internals of the frame.",
        "challenges": [
            "Scaling the images so that they would fit onto the custom touchscreen of the frame, which had a special aspect ration.",
            "Writing a custom slideshow app in Python",
            "Scheduling the frame to turn on and off automatically, and to load the slideshow app on boot."
        ],
        "futureImprovements": [],
        "techStack": ["Python", "Linux"],
        "folder": "birdcam_frame",
        "links": []
    },
    {
        "title": "AnimalCam",
        "summary": "AnimalCam is my BirdCam project‘s follow-up project, where I wanted to extend the project’s spectrum from only bird related pictures to pictures about all of our animals, since we are animal lovers and have many furry (and feathery) friends.",
        "motivation": "At the time of creating AnimalCam I was taking Web Application Development classes at university, so I wanted to create something with a LAMP (Linux, Apache, MySQL, PHP) stack.",
        "functionality": "AnimalCam is a fullstack project, meaning that I have my own local Linux server (that I configured on a Raspberry Pi), running a web application namely the AnimalCam website, accessible from the local network. It features a gallery, posts, a video livestream of the BirdCam and a cropping tool to help upload images.",
        "challenges": [
            "Creating my first full-stack app, configuring Apache Webserver on Linux.",
            "I didn't use any frontend styling libraries so making the app look not-terrible was really tedious.",
            "The image cropping functionality was quite hard to implement.",
            "Implementing a complex filtering mechanism via dynamicSQL queries."
        ],
        "futureImprovements": [
            "Using bootstrap or similar libraries to create a coherent styling."
        ],
        "techStack": ["PHP", "Linux", "Apache Webserver", "MySQL"],
        "folder": "animalcam",
        "links": []
    },
    {
        "title": "Personal Project Manager",
        "summary": "Personal Project Manager is one of my most complex full-stack projects made during my BSc studies.",
        "motivation": "Ever since I took a Databases course during my BSc I have been fascinated by databases and the amount of questions that can be answered by analysing the stored data. Having passed the databases course with flying colours I immediately wanted to put my knowledge to practice and make a database to keep track of my studying habits and projects. Once I finished with the database structure I quickly realised that without a custom-tailored application and interface, using the database to track my habits was a chore.",
        "functionality": "The application first asks for the login information of a Microsoft SQL Server instance, which can either be saved locally to then automatically load on the next startup or just used once as a temporary login. Once logged in the database’s tables are dynamically loaded into a list with each tile randomly coloured on each load without colour-repetition on adjacent tiles. When clicked the tables open an editor view which allows the user to insert, delete or update records in the given table. Pre-created view can also be viewed, showing the result set.",
        "challenges": [
            "I had to use multi-threading when connecting to a database, because SQL Server is notorious for taking a while to try to log in when wrong credentials are given, thus making the GUI freeze whilst waiting for a response. I had to implement a connection progress bar animation.",
            "This was my first JDBC project, I had difficulties with the DB driver when creating the final JAR file of my project, since I had to manually include the JDBC dependency in my final project JAR too.",
            "I had to make sure all the views and tables are dynamically loaded from the database to make sure modifications to the database are reflected in the application."
        ],
        "futureImprovements": [
            "A custom query window would be a great addition to the application, letting users to create any SQL query, thus showing the result set in a pop-up window would be possible.",
            "The hashing and salting of the stored passwords is STRONGLY recommended. Currently the server login passwords are stored as plain text since I only used the application locally with a local database instance.",
            "The app only works with MS SQL Server for now, but Derby integration would be an interesting addition."
        ],
        "techStack": ["Java", "JDBC", "MS SQL Server", "T-SQL", "JavaFX"],
        "folder": "personal_project_manager",
        "links": [{"name": "GitHub", "link": "https://github.com/raczmirko/personal-project-manager"}]
    },
    {
        "title": "Puzzle Center",
        "summary": "A twisty-puzzle Android app featuring a solve-timer, statistics, record-tracking and categorized algorithms for solving the puzzles.",
        "motivation": "I made this application after taking mobile app development lessons in university and really liking the portability of such apps. I have a collection of 80+ twisty puzzles, and I play with them from time to time. However, with many of them requiring different algorithms I often found myself searching the internet for certain algorithms that I had learned but forgot about, which took a lot of time and effor. So I wanted to create an app that keeps my favourite algorithms in one place. Then I also wanted it to be functional, so I added a puzzle timer, statistics and so on.",
        "functionality": "The app has three utilities and a collection of puzzle algorithms. The utilities are: A solve timer, which can be used to time puzzle solves and keep track of one's time improvements. A records page to keep track of one's personal records with each puzzle. And finally a statistics page to gain meaningful insights to one's solving capabilities, such as number of total solves, average of last 12 solves, most trained puzzle etc.",
        "challenges": [
            "This being my first Android app, app lifecycle management and other Android-specific ideas were something I had to get used to.",
            "The app's development is really slow, because for each puzzle category I have to do research on algorithms, learn the algorithms to know which ones I prefer and so on.",
            "Designing the icons for all puzzles was time consuming to say the least.",
            "Releasing the app on the Google Play Store was no easy task, I had to learn about app signing and many more."
        ],
        "futureImprovements": [
            "First and foremost, I want to finish this app at some point finally.",
            "I should probably implement some kind of SQLite database structure to store the algorithms instead of storing them as text.",
            "I would like to once re-write the app in a more modern framework or language, such as React Native."
        ],
        "techStack": ["Java", "Android"],
        "folder": "puzzle_center",
        "links": [
            {"name": "GitHub", "link": "https://github.com/raczmirko/puzzle-center"},
            {"name": "Google Play", "link": "https://play.google.com/store/apps/details?id=hu.okrim.puzzlecenter"}
        ]
    },
    {
        "title": "Truck Simulator Timer",
        "summary": "TruckSimulatorTimer is an Android app written in Java that helps convert in-game delivery times to real time in the famous simulator games Euro Truck Simulator and American Truck Simulator.",
        "motivation": "I like playing video games, especially simulator games. My favourites have always been Euro Truck Simulator 2 and American Truck Simulator. But I had this one problem where I never knew how much real time a specific delivery was going to take, as the in-game GPS only shows the estimated time in in-game time. I took matters in my own hand and developed an app to solve this problem.",
        "functionality": "The application has a timer functionality, that estimates the remaining drive time based on the input data such as total kilometres and ferry distance. Every delivery drive is saved to an SQLite database and is used to make further estimations in order to improve estimation precision. This is needed in order to counterweight all the traffic jams, red lights and driving manners that are not factored in to the original estimation. The estimation strategies can be manually configured in a settings page to make everything custom-fit to the user. A statistics page provides more in-depth details about the previous drives, such as overall estimation precision, estimation median, total drives, total time driven, etc. The database records can be manually reviewed and deleted in case of an error.",
        "challenges": [
            "I had to make sure the time functionality is precise to avoid any timing errors. I used multithreading for the timer.",
            "I had to make the estimation strategies configurable, from the sampling pool size to the expected traffic error rate.",
            "I had to make sure the database entries were manually viewable and removable in case of an erroneous record.",
            "I had to make sure the screen does not turn off whilst using the app.",
            "I had to thoroughly test the time estimation logic so that whenever the timer is paused, extended or modified during runtime it still yields a good result."
        ],
        "futureImprovements": [],
        "techStack": ["Java", "SQLite", "XML"],
        "folder": "truck_timer",
        "links": [
            {"name": "GitHub", "link": "https://github.com/raczmirko/truck-simulator-timer"},
            {"name": "Google Play", "link": "https://play.google.com/store/apps/details?id=hu.okrim.trucksimulatortimer"}
        ]
    },
    {
        "title": "Product Rating App",
        "summary": "ProductRatingApp is a fullstack project where I wanted to practice the technologies I got to use during my internship at Qlex: Java, Spring and JavaScript. I also used Thymeleaf for the frontend and SQL Server for the DB.",
        "motivation": "I like rating things I buy, be that different flavours of drinks, food or else. I also find it intriguing being able to analyse a set of data and find patterns, similarities and most importantly, answers to certain question. This is why I decided to make an application where I can rate different kinds of food and beverages.",
        "functionality": "The application allows users to create categories, flavours, brands. Each product is composed of a name, a brand, a category and different flavours. Users can then rate these products. On the home page some data-related information is shown, such as best rated products, recent ratings, etc. I wanted to share my project with my family members making it possible for anyone to leave product reviews. For this, my locally ran application was not suitable and I needed to host it on a Raspberry Pi micro computer on the local network. However, on Linux there is no Microsoft SQL Server support, so I needed to use MariaDB as an alternative. Once I configured the DB, I wrote a BASH script that clones the project’s GitHub repository, and scheduled this script to run periodically via cron, this made it easy to update the app whenever I release a new commit. This made it possible to host my app locally on a Linux-based Rapsberry Pi.",
        "challenges": [
            "It was my first time using Maven as a build tool so I had to get familiar with it.",
            "The card-like tag system with the custom CSS animations was quite challenging to develop.",
            "I tried to create the interface with my best attention to detail, making it quite a puzzle sometimes, especially on the CSS part.",
            "Creating the Raspberry Pi powered local deploy."
        ],
        "futureImprovements": [
            "Since I wrote the application for personal use with my family members, currently each time a rating is submitted the rating’s user must be manually selected, meaning that any user can be selected. In a public system user authentication and login should be implemented with password hashing. Thus a login system would be a meaningful addition.",
            "The application doesn’t currently contain many queries and statistics, these should be added.",
            "Editing and deleting reviews is currently not supported, but should be."
        ],
        "techStack": ["Java", "Spring", "JavaScript", "Bootstrap", "Thymeleaf", "MS SQL Server"],
        "folder": "product_rating_app",
        "links": [
            {"name": "GitHub", "link": "https://github.com/raczmirko/product-rating-app"}
        ]
    },
    {
        "title": "Product Rating App 2.0",
        "summary": "A Spring & React web application that uses a carefully desinged underlying Microsoft SQL Server database (which was my BSc diploma work) to meaningfully review products. Using MUI for a beautiful frontend.",
        "motivation": "My BSc diploma work was about designing a relational database structure to meaningfully review products. With such a complex DB at disposition, I though it would be a really interesting project to create a complete web application where this structure could be used. To make the whole frontend as polished as the carefully designed database, I choose to learn React and use this project to practice my newly learned skills. I chose to use Material UI (MUI), which is a React component library that follows guidelines such as Google’s material design principles, which makes it incredibly nice on the eyes and intuitive to use.",
        "functionality": "The system in question allows for the evaluation of products based on various criteria, such as taste, packaging, color, etc. Products can be food items, consumer goods, electronics, and so on. The system maintains records of conceptual products, i.e., items that can be purchased as specific products in various packaging options at stores. Each item has a brand and can be categorized, and the categories can be hierarchically organized (main category and subcategories) up to a depth of 3. For example, a main category could be beverages, with its subcategories being tea or coffee. Each category has characteristics (e.g., color, taste), and products belonging to that category can have these characteristics. Additionally, every category can be evaluated based on certain criteria (e.g., taste for the beverage category). Products belonging to a given category can be rated on a scale from 1 to 5 as part of the product reviews, based on the criteria specific to the category, as well as inherited criteria from higher-level categories. Product images can also be stored for each product. Each evaluation comes from an individual and pertains to a specific product. Every data modification is logged in the system.",
        "challenges": [
            "Implementation of JSON Web Token based authentication mechanism along with RESTful APIs.",
            "Creating an intuitive frontend for such a complex database structure.",
            "Session management",
            "Permissions and roles"
        ],
        "futureImprovements": [
            "Since I developed this application for personal use, I didn’t spend too much time on creating different permissions and roles, however the application is prepared for such modifications and these could be implemented to enhance functionality.",
            "It would be interesting to implement AI to create more complex statistics and dashboards based on ratings."
        ],
        "techStack": ["Java", "Spring", "Maven", "JWT", "React", "MUI (Material UI)", "MUI-X","MS SQL Server", "ParticleJS"],
        "folder": "product_review_app",
        "links": [
            {"name": "GitHub backend repo", "link": "https://github.com/raczmirko/product-review-app-complete-backend"},
            {"name": "GitHub frontend repo", "link": "https://github.com/raczmirko/product-review-app-complete-frontend-mui"}
        ]
    }
]